`onRouteMatched`와 `refreshData` 함수는 각각 다른 목적을 위해 존재하며, 둘 다 필요합니다. 이들의 역할과 함께, 왜 둘 다 필요한지 설명드리겠습니다.

### `onRouteMatched` 함수의 역할
- **라우트 매칭 시 동작**: 이 함수는 사용자가 특정 라우트(즉, 특정 화면)에 도달할 때 실행됩니다. 예를 들어, 사용자가 다른 화면에서 돌아오거나, 브라우저에서 해당 URL을 직접 입력하는 경우가 있을 수 있습니다.
- **데이터 새로고침 트리거**: 이 함수는 화면이 활성화될 때마다 데이터가 최신 상태인지 확인하기 위해 `refreshData`를 호출하여 데이터를 새로고침하도록 트리거합니다.

### `refreshData` 함수의 역할
- **실제 데이터 갱신**: `refreshData`는 화면에 바인딩된 데이터를 새로고침하는 실제 작업을 수행합니다. `oBinding.refresh()`를 호출하여 테이블의 데이터를 서버에서 다시 가져오도록 합니다.

### 왜 둘 다 필요한가?
- **역할 분리**: `onRouteMatched`는 특정 라우트에 도달했을 때 무엇을 해야 하는지를 정의하는 곳이고, `refreshData`는 데이터 새로고침의 구체적인 동작을 수행하는 곳입니다.
- **재사용성**: `refreshData` 함수는 데이터 갱신이 필요할 때 어디서든 호출할 수 있습니다. 예를 들어, 다른 이벤트(사용자가 특정 버튼을 클릭하거나 데이터가 변경된 후)에서도 `refreshData`를 호출할 수 있습니다. 이렇게 분리하면 동일한 데이터 새로고침 로직을 여러 곳에서 재사용할 수 있습니다.
- **확장성**: 만약 `onRouteMatched`에서 데이터 새로고침 외에 추가적인 로직이 필요하다면, `refreshData`와 별도로 해당 로직을 추가할 수 있습니다.

### 요약
- **`onRouteMatched`**: 라우트가 매칭될 때 필요한 동작을 정의하는 함수입니다. 여기서 `refreshData`를 호출하여 데이터 갱신을 트리거합니다.
- **`refreshData`**: 데이터 바인딩을 새로고침하는 실제 작업을 담당하는 함수입니다. 

이 두 함수는 각각 다른 목적을 위해 존재하며, 역할 분리와 재사용성 측면에서 모두 필요합니다.